#!/bin/bash

# "createme" script.

#  Copyright (c) 2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  This script must be run from inside a Linux source directory

usage()
{
cat << EOF

    createme [-v] [--disable-meta-gen] <arch> <branch> [defconfig]

      --disable-meta-gen: do not automatically create meta data
                          if not already present in the source tree.
      -v: verbose processing
      <arch>: the kernel architecture being processed
      <branch>: repository branch to use or create

EOF
}


meta_dir=meta
if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help)
		usage
		exit
		;;
            --disable-meta-gen)
                must_have_meta=t
                ;;
	    --force)
		force=t
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

arch=$1
branch=$2
defconfig=$3 # might be empty
CURRENT=`git branch |grep \*|sed 's/^\* //'`
repo=

check_repo()
{
	action=$1

	git show-ref --quiet --verify -- "refs/heads/wrs_meta"
	if [ $? -eq 0 ]; then
		meta_branch=wrs_meta
	fi
	git show-ref --quiet --verify -- "refs/heads/meta"
	if [ $? -eq 0 ]; then
		meta_branch=meta
	fi

	if [ "$action" = "sanitize" ]; then
		git show-ref --quiet --verify -- "refs/tags/checkpoint-$meta_branch"
		if [ $? -eq 1 ]; then
			if [ -n "$must_have_meta" ]; then
				echo "ERROR. meta data not found, check upstream repo for tags and branches"
				exit 1
			else
				echo "WARNING: checkpoint tag not found, creating .."
				git tag "checkpoint-$meta_branch"
			fi
		fi
	else
		if [ -n "$meta_branch" ]; then
			echo "meta-data"
		else	    
			echo "external"
		fi
	fi
}

metaize()
{
	kbranch=$1

	old_pwd=`pwd`
	if [ "$repo" = "external" ]; then
		echo $kbranch | grep -q "/"
		if [ $? -eq 0 ]; then
			# remove trailing "/base" that won't be in the .scc files themselves
			tgt=`echo $kbranch | sed 's%/base$%%'`
			# the parent branch is the second to last, i.e. standard/common_pc
			# so we can reverse everything and take the second field
			parent=`echo $tgt | rev | cut -d'/' -f2 | rev`
			short_branchname=`echo $tgt | rev | cut -d'/' -f1 | rev`
			ktgt=$short_branchname-$parent
		else
		    ktgt=$kbranch
		    short_branchname=$kbranch
		    parent=$kbranch
		fi

		mkdir -p $meta_dir/cfg/kernel-cache

		version=`grep -E "^VERSION =" Makefile | cut -d\= -f2 | sed 's/ //g'`
		patchlevel=`grep -E "^PATCHLEVEL =" Makefile | cut -d\= -f2 | sed 's/ //g'`
		sublevel=`grep -E "^SUBLEVEL =" Makefile | cut -d\= -f2 | sed 's/ //g'`
		echo -n "v" >> $meta_dir/cfg/kernel-cache/kver
		echo -n "$version" >> $meta_dir/cfg/kernel-cache/kver
		echo -n "." >> $meta_dir/cfg/kernel-cache/kver
		echo -n "$patchlevel" >> $meta_dir/cfg/kernel-cache/kver
		echo -n "." >> $meta_dir/cfg/kernel-cache/kver
		echo "$sublevel" >> $meta_dir/cfg/kernel-cache/kver

		mkdir -p $meta_dir/cfg/scratch/obj
		cd $meta_dir/cfg/scratch/obj

		(cd $old_pwd; find -name 'Kconfig' | sed 's/^.\///' > $meta_dir/cfg/scratch/obj/hardware.kcf)
	fi
}

# Steal the wrs data off of the wrs_meta branch, but dont actually
# change the meta in the process...
decheckpoint()
{	
	check_repo sanitize
	case `check_repo identify` in
		meta-data)
	       		repo=meta-data
			# Is the meta-data merged out to the other branches? If so
			# that means that we don't need to undo the checkpoint. We can tell
			# by counting how many contain the meta data. If it's 2 or less, then
			# we need to restore the checkpoint.
			branch_count=`git branch --contains $meta_branch | wc -l`
			if [ $branch_count -le 2 ]; then
				kgit-checkpoint -r
			fi
			;;
		external)
			if [ -n "$must_have_meta" ]; then
				echo "ERROR. meta data not found. Check upstream kernel for tags and branches"
				exit 1
			fi
			repo=external
			;;
	esac

	if [ -d wrs ]; then
		meta_dir=wrs
	else
		meta_dir=meta
	fi
}

# checks and sets
check_defconfig() {
	config=$1

	defconfig=`get_defconfig $arch $config`
}

# checks and creates
check_branch() {
	branch=$1
	defconfig=$2

	ktgt=$branch

	old_pwd=`pwd`
	git show-ref --quiet --verify -- "refs/heads/$ktgt"
	if [ $? -eq 1 ]; then
	    if [ -n "$verbose" ]; then
		echo "[INFO] branch $branch does not exist ... creating"
	    fi

            # we need to condition the branch. If it is in the form that
	    # uses / for inheritance, special processing needs to be done.
            echo $ktgt | grep -q "/"
	    if [ $? -eq 0 ]; then
    	        # remove trailing "/base" that won't be in the .scc files
    	        # themselves
		tgt=`echo $ktgt | sed 's%/base$%%'`
		target=`echo $tgt | rev | cut -d'/' -f1 | rev`
		parent=`echo $tgt | sed "s%/$target%%"`
		
		# parent may be a "base" branch, so we test
		git show-ref --quiet --verify -- "refs/heads/$parent"
		if [ $? -eq 1 ]; then
		    git show-ref --quiet --verify -- "refs/heads/$parent/base"
		    if [ $? -eq 1 ]; then
			# fallback
			parent=$CURRENT
		    else
			parent="$parent/base"
		    fi
		fi
            else
		parent=`echo $ktgt | rev | cut -d'-' -f1 | rev`
	    fi

	    mkdir -p $meta_dir/cfg/scratch/obj
	else
	    # branch exists. Are we an 'external repo' ?
	    if [ "$repo" == "external" ]; then
		git checkout $ktgt
	    fi
	fi

	cd $old_pwd
}


decheckpoint
check_defconfig $defconfig
check_branch $branch $defconfig
metaize $branch
