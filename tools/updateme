#!/bin/bash

# "updateme" script.

#  Copyright (c) 2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  This script must be run from inside a Linux source directory

usage()
{
cat << EOF

    updateme <dirs>

EOF
}


if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help)
		usage
		exit
	        ;;
	    --features)
		cmd_line_features="$2"
		shift
		;;
	    --force)
		force=t
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

# arg1 is the ARCH
arch=$1
shift
# everything else is features
command_line_dirs=$@
CURRENT=`git branch |grep \*|sed 's/^\* //'`

gen_dirs() {
	top_dir=$1

	potential=`find $top_dir -maxdepth 3 -type d -name kernel*cache`
	for dir in $potential; do
	    search_dirs="$search_dirs $dir"
	    includes="$includes -I $dir"
	done
}

# searches for extra files to build
find_features() {
	dirs=$@

	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.scc`
	    extra_features="$extra_features $potential"
	done
}

# searches for extra configs to include, only if they haven't
# been pulled into a .scc file already
find_configs() {
	dirs=$@
	
	# defconfigs should be found first, so fragements can tweak
	# settings
	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name defconfig`
	    scc_files=`find $d -maxdepth 1 -type f -name *.scc` 
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the fragement
		if [ -n "$scc_files" ]; then
			grep $b $d/*.scc -q
			if [ $? -ne 0 ]; then
		    		extra_cfgs="$extra_cfgs $f"
			fi
		else
			extra_cfgs="$extra_cfgs $f"
		fi
	    done
	done

	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.cfg`
	    scc_files=`find $d -maxdepth 1 -type f -name *.scc` 
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the fragement
		if [ -n "$scc_files" ]; then
			grep $b $d/* -q
			if [ $? -ne 0 ]; then
		    		extra_cfgs="$extra_cfgs $f"
			fi
		else
			extra_cfgs="$extra_cfgs $f"
		fi
	    done
	done
}

# searches for extra patches to include, only if they haven't
# been pulled into a .scc file already
find_patches() {
	dirs=$@
	
	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.patch`
	    potential="$potential `find $d -maxdepth 1 -type f -name *.diff`"
	    potential="$potential `find $d -maxdepth 1 -type f -name *.mbox`"
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the patch
		grep $b $d/* -q
		if [ $? -ne 0 ]; then
		    extra_patches="$extra_patches $f"
		fi
	    done
	done
}

do_compile_prep() {
	top_dir=$1

	mkdir -p wrs/cfg/meta/obj
	(cd wrs/cfg/meta/obj
	    rm -f *.sco
	)

	# updates 'includes' and 'search_dirs'
	gen_dirs $top_dir
	includes="-I $top_dir $includes"
	search_dirs="$top_dir $search_dirs"
}

search_includes()
{
	search_expr=$1
	parent_leaf=$2

	for dir in $search_dirs; do
            if [ -n "$tgt" ]; then
		continue
            fi

            found=`find $dir/ -regex "$search_expr"`
            if [ -n "$found" ]; then
		for f in $found; do
                    if [ -n "$tgt" ]; then
			continue
                    fi
                    if [ "$parent_leaf" != "any" ]; then
			x=`grep "scc_leaf" $f`
			if [ -n "$x" ]; then
                            echo "$x" | grep -q -w $parent_leaf
                            if [ $? -eq 0 ]; then
				tgt=$f
                            fi
			fi
                    else
			tgt=$f
                    fi
		done
            fi
	done

	echo $tgt
}

do_update() {
	branch=$1
	top_dir=$2

	ktgt=$branch

	top_tgt=`search_includes ".*/$ktgt.scc" any`

        # if there isn't a target .. we'll need to create one
	if [ -z "$top_tgt" ]; then
	    target=${ktgt%-*}
	    parent=`echo $ktgt | rev | cut -d'-' -f1 | rev`

	    # we need to generate a baseline configuration
	    (cd wrs/cfg/meta/obj
		echo "# auto generated BSP file" > $ktgt.scc
		echo "define WRS_BOARD $target" >> $ktgt.scc
		echo "define WRS_KERNEL $parent" >> $ktgt.scc
		echo "define WRS_ARCH $arch" >> $ktgt.scc
		echo "" >> $ktgt.scc

		echo "scc_leaf ktypes/$parent $ktgt" >> $ktgt.scc
	    )

	    top_tgt=wrs/cfg/meta/obj/$ktgt.scc
	fi

	# this builds and applies the meta-series
	( cd wrs/cfg/meta/obj
	    if [ -n "$extra_cfgs" ]; then
		for c in $extra_cfgs; do
		    b=`basename $c`
		    cp $c .
		    echo "kconf non-hardware $b" >> auto_feat.scc
		done
	    
		extra_features="$extra_features auto_feat.scc"
	    fi

	    if [ -n "$extra_patches" ]; then
		for c in $extra_patches; do
		    b=`basename $c`
		    cp $c .
		    echo "patch $b" >> auto_feat.scc
		done
	    
		echo "$extra_features" | grep -q auto_feat.scc
		if [ $? -ne 0 ]; then
		    extra_features="$extra_features auto_feat.scc"
		fi
	    fi

	    scc -o $ktgt $includes $top_tgt $extra_features $addon_features

	    if [ -e "$ktgt" ]; then
		bash ./$ktgt > ../$ktgt-meta
	    else
		echo "ERROR. Could not find an excutable target for $branch"
	    fi
	)
}

process_args()
{
	args=$@

	for a in $args; do
		if [ -d $a ]; then
			feature_dirs="$feature_dirs $a"
		else
			features_to_find="$features_to_find $a"	
		fi
	done
}

do_addon_features()
{
	feats=$@

	for f in $feats; do
		for d in $search_dirs; do
			potential=`find $d -name $f`
			if [ -n "$potential" ]; then
				addon_features="$addon_features $potential"
			else
				if [ -e "$d/$f" ]; then
				        # if it is a directory, only pass the dir name.
					if [ -d "$d/$f" ]; then
						addon_features="$addon_features $f"
					else
						addon_features="$addon_features $d/$f"
					fi
				fi
			fi
		done
	done
}


# $PWD is the Linux src directory
linux_src_dir=`pwd`

do_compile_prep $linux_src_dir

# sorts the command line options and returns "feature_dirs" and 
# "features_to_find"
process_args $command_line_dirs

find_features $feature_dirs
find_configs $feature_dirs
find_patches $feature_dirs

do_addon_features $cmd_line_features $features_to_find

do_update $CURRENT $linux_src_dir
