#!/bin/bash

# Script to build all possible BSP branches in a git yocto kernel tree.
# Copyright 2012 Wind River.  Licensed under the GPLv2 included herein
# by reference.

# Requirements:
#	Toolchain for each arch.
#	$PATH which includes the above.
#	Proper CROSS_COMPILE (per arch) settings; see defaults below.

# Optional:
#	ccache
#	distcc

#
# Stick all your customizations, local $PATH additions in the below.
#
if [ -f $HOME/.buildallrc ]; then
	echo Sourcing custom settings in $HOME/.buildallrc
	source $HOME/.buildallrc
fi

if [ -z "$JOBS" ]; then
	JOBS=20
fi

if [ -z "$NICE" ]; then
	NICE=15
fi

# The (bare) git tree that you want build tested.
# TREE=~/workdir/foo.git
#   or
# TREE=git://some.site.com/linux.git
# both absolute paths and git repos are valid inputs
if [ -z "$TREE" ]; then
	TREE=git://git.yoctoproject.org/linux-yocto-3.4
fi

# Name of dir created for containing checked out src to build from
if [ -z "$LINUX_SRC" ]; then
	LINUX_SRC=linux
fi

# Name of dir created for bare clone used as base tree.
if [ -z "$DEFKERN" ]; then
	DEFKERN=default_kernel
fi

# Where all the radioactive fallout is contained
if [ -z "$BUILDALL" ]; then
	BUILDALL=kernel_builds
fi

# If non fatal warnings are issued by this script, they are here
if [ -z "$WARN_LOG" ]; then
	WARN_LOG=warnings.txt
fi

# to save on clones, check std location.
if [ -z "$REFERENCE" ]; then
	REFERENCE=~/git/linux
fi

# Sane defaults
if [ -z "$PPC_CROSS_COMPILE" ]; then
	PPC_CROSS_COMPILE=powerpc-poky-linux-
fi

if [ -z "$MIPS_CROSS_COMPILE" ]; then
	MIPS_CROSS_COMPILE=mips-poky-linux-
fi

if [ -z "$ARM_CROSS_COMPILE" ]; then
	ARM_CROSS_COMPILE=arm-poky-linux-gnueabi-
fi

if [ -z "$X86_CROSS_COMPILE" ]; then
	X86_CROSS_COMPILE=i586-poky-linux-
fi

if [ -z "$X86_64_CROSS_COMPILE" ]; then
	X86_64_CROSS_COMPILE=x86_64-poky-linux-
fi

MYPATH=`dirname $0`
CONFIGME=$MYPATH/configme

if [ -d $TREE ]; then
	TREE=`readlink -f $TREE`
fi

if [ ! -x $CONFIGME ];then
	echo Error: Cant locate configuration script \"configme\"
	echo Was looking for $CONFIGME
	exit 1
fi

######## build one branch; assumes it is checked out and config'd ######
build_branch()
{

	if [ -z "$ARCH" ]; then
		echo ARCH not set, cant build $BUILD_DIR
		return 1
	fi

	if [ "$ARCH" == "powerpc" ];then
		CROSS_COMPILE=$PPC_CROSS_COMPILE
	elif [ "$ARCH" == "i386" ];then
		CROSS_COMPILE=$X86_CROSS_COMPILE
	elif [ "$ARCH" == "x86" ];then
		CROSS_COMPILE=$X86_CROSS_COMPILE
	elif [ "$ARCH" == "x86_64" ];then
		CROSS_COMPILE=$X86_64_CROSS_COMPILE
	elif [ "$ARCH" == "mips" ];then
		CROSS_COMPILE=$MIPS_CROSS_COMPILE
	elif [ "$ARCH" == "arm" ];then
		CROSS_COMPILE=$ARM_CROSS_COMPILE
	else
		echo Unknown architecture: $ARCH -- Giving up.
		return 1
	fi

	# Find the arch specific gcc for the toolchain
	which $CROSS_COMPILE\gcc > /dev/null 2>&1
	if [ $? != 0 ]; then
		echo Error: cant find a $CROSS_COMPILE\gcc in PATH
		echo PATH is: $PATH
		exit 1
	fi

	# Sanity checks specific to distcc/ccache usage
	if [ ! -z "$CCACHE_PREFIX" ]; then
		which ccache > /dev/null 2>&1
		if [ $? != 0 ]; then
			echo Warning: cant find ccache in PATH
		fi

		TC_GCC=`which $CROSS_COMPILE\gcc`
		cmp -s $TC_GCC $CCACHE
		if [ $? != 0 ]; then
			echo Warning: $TC_GCC doesnt point at ccache
			echo perhaps your toolchain is ahead of ccache in your path\?
		fi
	fi

	export ARCH
	export CROSS_COMPILE

	command time --quiet -f '%E' -o time.log nice -n $NICE \
		make -j$JOBS O=$BUILD_DIR > $BUILD_DIR/build.log 2>&1

	return $?
}

debare()
{
	mkdir .git
	if [ $? != 0 ]; then
		echo debare: you already have a .git in $PWD
		echo fix your shit
		exit 1
	fi
	mv * .git
	git config core.bare false
}

# We could omit this step, but it makes the remainder of things
# indifferent to where things came from.
clone_local()
{
	git clone --bare --shared $TREE $DEFKERN > /dev/null 2>&1
	if [ $? != 0 ]; then
		echo clone of $TREE failed
		echo I tried to run: \"git clone --bare --shared $TREE $DEFKERN\"
		exit 1
	fi
}

clone_ref()
{
	if [ -d $REFERENCE ]; then
		REF="--reference $REFERENCE"
	fi
	git clone --bare $REF $TREE $DEFKERN > /dev/null 2>&1
	if [ $? != 0 ]; then
		echo clone of $TREE failed
		echo I tried to run: \"git clone --bare $REF $TREE $DEFKERN\"
		exit 1
	fi
}

stage_src()
{
	git clone --bare --shared --no-checkout $DEFKERN $LINUX_SRC>/dev/null 2>&1
	if [ $? != 0 ]; then
		echo shared clone of default_kernel failed
		echo I tried to run: \"git clone --bare --shared --no-checkout $DEFKERN $LINUX_SRC\"
		exit 1
	fi

	# De-bare the clone.  There should be a command for this...
	cd $LINUX_SRC
	debare

	git checkout -f meta > /dev/null 2>&1
	if [ $? != 0 ];then
		echo checkout of meta failed
		exit 1
	fi
}

get_branch()
{
	if [ ! -f "$1" ]; then
		echo get_branch: $1: file does not exist >&2
		return
	fi
	for i in `cat $1 |grep _branch_begin| awk '{print $3}'` ; do
		echo -n $i/
	done | sed 's,/$,,'
}

######################### start #####################

which mkimage > /dev/null 2>&1
if [ $? != 0 ]; then
	echo Error -- you dont have a mkimage in your path, needed for
	echo powerpc builds.  Go get one from the u-boot tree.
	exit 1
fi

if [ -d $BUILDALL ]; then
	echo Destination dir \"$BUILDALL\" already exists. Be careful!
	sleep 1
fi

echo Using $TREE as upstream source
echo You can use \"export TREE=git://myhost.com/mypath\" to change.
echo Doing initial setup....
mkdir -p $BUILDALL
cd $BUILDALL
echo "Infrastructural warnings from this run:" > $WARN_LOG

if [ -d $DEFKERN ]; then
	echo Dir $DEFKERN already exists - assuming resuming prev. run.
else
	if [ -d $TREE ]; then
		TREE=`readlink -f $TREE`
		clone_local
	else
		clone_ref
	fi
fi

# Set us up a linux dir and checkout meta
if [ ! -d $LINUX_SRC ]; then
	stage_src
fi

# Create a mapping between scc and meta series and arch and branch
META_LIST=`mktemp`
for i in `grep -Rl '^define KMACHINE' meta/cfg/kernel-cache` ; do
	SCC=`basename $i .scc`
	KMACHINE=`grep '^define KMACHINE' $i | head -n1 |awk '{print $3}'`
	KTYPE=`grep '^define KTYPE' $i | awk '{print $3}'`
	KARCH=`grep '^define KARCH' $i | awk '{print $3}'`
	META=$SCC-meta

	if [ ! -f meta/cfg/meta/$META ]; then
		echo Cant find meta series for $i
		echo I expected to find meta/cfg/meta/$META
		exit 1
	fi

	BRANCH=`get_branch meta/cfg/meta/$META`
	if [ -z "$BRANCH" ]; then
		echo Cant find branch for $META
		exit 1
	fi

	git rev-parse $BRANCH > /dev/null 2>&1
	if [ $? != 0 ]; then
		BRANCH=$BRANCH/base
		git rev-parse $BRANCH > /dev/null 2>&1
		if [ $? != 0 ]; then
			echo Cant find base branch \($BRANCH\) for $META
			exit 1
		fi
	fi
	#        1        2      3     4      5     6
	echo $KMACHINE $KTYPE $KARCH $META $BRANCH $SCC >> $META_LIST
done

# Move off meta branch before making meta content become untracked
git checkout -f standard/base 2>/dev/null
if [ $? != 0 ]; then
	echo fatal: checkout of standard/base failed
	exit 1
fi
$MYPATH/kgit-checkpoint -r > /dev/null 2>&1

for i in `cat $META_LIST| awk '{print $6}'` ; do
	BRANCH=`grep $i $META_LIST | awk '{print $5}'`
	MACHINE=`grep $i $META_LIST | awk '{print $1}'`
	ARCH=`grep $i $META_LIST | awk '{print $3}'`
	KTYPE=`grep $i $META_LIST | awk '{print $2}'`

	git checkout -f $BRANCH 2>/dev/null
	if [ $? != 0 ]; then
		echo fatal: checkout of $BRANCH failed
		exit 1
	fi
	
	BUILD_DIR=../$i

	readlink -f `find meta -name $i.scc`  > meta/top_tgt
	$CONFIGME -o ../$i $KTYPE $MACHINE > cfg.log 2>&1
	if [ $? != 0 ]; then
		echo Configuration of $i failed
		mv cfg.log ../0-FAIL-cfg-$i.log
		continue
	fi

	mv cfg.log $BUILD_DIR

	echo -n "Building $BRANCH for $i, status: "
	build_branch > error.log 2>&1
	if [ $? != 0 ]; then
		echo -n FAILED.
		if [ -f $BUILD_DIR/build.log ]; then
			mv $BUILD_DIR/build.log ../0-FAIL-build-$i
		else
			mv error.log ../0-FAIL-build-$i
		fi
	else
		echo -n passed.
		mv $BUILD_DIR/build.log ../0-PASS-build-$i
	fi
	if [ -f time.log ]; then
		echo " (`cat time.log`)"
		rm -f time.log
	else
		 echo
	fi
	if [ -s error.log ] ; then
		echo On branch $BRANCH for $i: >> ../$WARN_LOG
		cat error.log >> ../$WARN_LOG
	fi
	rm -f error.log
done

cd ..

PASS_CFG=`ls -1 0-PASS-cfg-* 2>/dev/null |wc -l`
FAIL_CFG=`ls -1 0-FAIL-cfg-* 2>/dev/null |wc -l`
TOTAL_CFG=`expr $PASS_CFG + $FAIL_CFG`

PASS_BUILD=`ls -1 0-PASS-build-* 2>/dev/null |wc -l`
FAIL_BUILD=`ls -1 0-FAIL-build-* 2>/dev/null |wc -l`
TOTAL_BUILD=`expr $PASS_BUILD + $FAIL_BUILD`

echo ========================= Build Summary ============================
echo Kernel config: Total: $TOTAL_CFG, Pass: $PASS_CFG, Fail: $FAIL_CFG
echo Kernel build:  Total: $TOTAL_BUILD, Pass: $PASS_BUILD, Fail: $FAIL_BUILD
echo ====================================================================

RET=`expr $FAIL_CFG + $FAIL_BUILD`
if [ $RET != "0" ];then
	echo Do a \"ls \*FAIL\*\" for more details.
fi
exit $RET

########################################################
# Local variables:
# enable-local-eval: t
# hack-local-variables-hook: save-buffers-kill-emacs
# end:
